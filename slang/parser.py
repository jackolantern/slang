#!/usr/bin/env python

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.

from __future__ import annotations

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu
from tatsu.parsing import leftrec, nomemo, isname  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {
    "in",
    "type",
    "then",
    "let",
    "true",
    "this",
    "namespace",
    "import",
    "function",
    "if",
    "false",
    "else",
}  # type: ignore


class SLANGBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re="\\(\\*((?:.|\\n)*?)\\*\\)",
        eol_comments_re="\\/\\/.*?$",
        ignorecase=None,
        namechars="",
        **kwargs
    ):
        super().__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class SLANGParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re="\\(\\*((?:.|\\n)*?)\\*\\)",
        eol_comments_re="\\/\\/.*?$",
        ignorecase=None,
        left_recursion=True,
        parseinfo=True,
        keywords=None,
        namechars="",
        tokenizercls=SLANGBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            tokenizercls=tokenizercls,
            **kwargs
        )

    @tatsumasu()
    @nomemo
    def _start_(self):  # noqa
        self._block_region_()
        self.name_last_node("@")
        self._cut()
        self._check_eof()

    @tatsumasu()
    def _block_(self):  # noqa
        self._token("{")
        self._cut()
        self._block_region_()
        self.name_last_node("@")
        self._token("}")

    @tatsumasu()
    @nomemo
    def _block_region_(self):  # noqa
        def block1():
            self._statement_()

        self._closure(block1)
        self.name_last_node("statements")
        with self._group():
            with self._choice():
                with self._option():
                    self._expression_()
                with self._option():
                    self._cut()
                    self._forgot_expression_()
                self._error("expecting one of: " "<expression> '~'")
        self.name_last_node("expression")
        self._define(["expression", "statements"], [])

    @tatsumasu()
    def _statement_(self):  # noqa
        with self._choice():
            with self._option():
                self._bang_()
                self.name_last_node("@")
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token(";")
                        with self._option():
                            self._cut()
                            self._forgot_semicolon_()
                        self._error("expecting one of: " "';' '~'")
            with self._option():
                self._import_file_()
                self.name_last_node("@")
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token(";")
                        with self._option():
                            self._cut()
                            self._forgot_semicolon_()
                        self._error("expecting one of: " "';' '~'")
            with self._option():
                self._assignment_()
                self.name_last_node("@")
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token(";")
                        with self._option():
                            self._cut()
                            self._forgot_semicolon_()
                        self._error("expecting one of: " "';' '~'")
            self._error(
                "expecting one of: "
                "'!' <bang> 'import' <import_file> 'let'"
                "<assignment>"
            )

    @tatsumasu()
    def _forgot_semicolon_(self):  # noqa
        with self._if():
            with self._group():
                with self._choice():
                    with self._option():
                        self._statement_()
                    with self._option():
                        self._expression_()
                    with self._option():
                        self._check_eof()
                    self._error("expecting one of: " "<statement> <expression>")
        self.name_last_node("x")
        self._define(["x"], [])

    @tatsumasu()
    def _forgot_expression_(self):  # noqa
        with self._if():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token("}")
                    with self._option():
                        self._check_eof()
                    self._error("expecting one of: " "'}'")
        self.name_last_node("x")
        self._define(["x"], [])

    @tatsumasu()
    def _bang_(self):  # noqa
        self._token("!")
        self._cut()
        self._expression_()
        self.name_last_node("expression")
        self._define(["expression"], [])

    @tatsumasu()
    def _assignment_(self):  # noqa
        self._token("let")
        self._cut()
        self._identifier_()
        self.name_last_node("name")
        self._token("=")
        self._expression_()
        self.name_last_node("expression")
        self._define(["expression", "name"], [])

    @tatsumasu()
    def _import_file_(self):  # noqa
        self._token("import")
        self._cut()
        self._string_()
        self.name_last_node("path")
        self._define(["path"], [])

    @tatsumasu()
    @nomemo
    def _expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._block_()
            with self._option():
                self._import_file_()
            with self._option():
                self._function_()
            with self._option():
                self._if_then_else_()
            with self._option():
                self._relational_expression_()
            self._error(
                "expecting one of: "
                "'{' <block> 'import' <import_file>"
                "'function' 'if' <if_then_else>"
                "<relational_binary_operation>"
                "<additive_expression>"
                "<relational_expression>"
            )

    @tatsumasu()
    def _function_(self):  # noqa
        self._token("function")
        self._cut()
        self._token("(")

        def block0():
            self._parameter_()
            self.add_last_node_to_name("parameters")

            def block2():
                self._token(",")
                self._parameter_()
                self.add_last_node_to_name("parameters")

            self._closure(block2)

        self._closure(block0)
        self._token(")")
        self._expression_()
        self.name_last_node("body")
        self._define(["body"], ["parameters"])

    @tatsumasu()
    def _parameter_(self):  # noqa
        self._identifier_()
        self.name_last_node("name")
        self._define(["name"], [])

    @tatsumasu()
    def _namespace_(self):  # noqa
        self._token("namespace")
        self._cut()
        self._token("{")

        def block0():
            self._definition_()
            self.add_last_node_to_name("definitions")

        self._closure(block0)
        self._token("}")
        self._define([], ["definitions"])

    @tatsumasu()
    def _definition_(self):  # noqa
        self._identifier_()
        self.name_last_node("name")
        self._token("=")
        self._cut()
        self._expression_()
        self.name_last_node("value")
        self._token(";")
        self._define(["name", "value"], [])

    @tatsumasu()
    @leftrec
    def _relational_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._relational_binary_operation_()
            with self._option():
                self._additive_expression_()
            self._error(
                "expecting one of: "
                "<relational_binary_operation>"
                "<additive_expression>"
                "<relational_expression>"
                "<additive_binary_operation>"
                "<multiplicative_expression>"
            )

    @tatsumasu()
    @nomemo
    def _relational_binary_operation_(self):  # noqa
        with self._choice():
            with self._option():
                self._relational_expression_()
                self.name_last_node("lhs")
                self._token("==")
                self.name_last_node("op")
                self._cut()
                self._additive_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._relational_expression_()
                self.name_last_node("lhs")
                self._token("<=")
                self.name_last_node("op")
                self._cut()
                self._additive_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._relational_expression_()
                self.name_last_node("lhs")
                self._token(">=")
                self.name_last_node("op")
                self._cut()
                self._additive_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._relational_expression_()
                self.name_last_node("lhs")
                self._token("<")
                self.name_last_node("op")
                self._cut()
                self._additive_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._relational_expression_()
                self.name_last_node("lhs")
                self._token(">")
                self.name_last_node("op")
                self._cut()
                self._additive_expression_()
                self.name_last_node("rhs")
            self._error(
                "expecting one of: "
                "<relational_binary_operation>"
                "<additive_expression>"
                "<relational_expression>"
                "<additive_binary_operation>"
                "<multiplicative_expression>"
            )
        self._define(["lhs", "op", "rhs"], [])

    @tatsumasu()
    @leftrec
    def _additive_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._additive_binary_operation_()
            with self._option():
                self._multiplicative_expression_()
            self._error(
                "expecting one of: "
                "<additive_binary_operation>"
                "<multiplicative_expression>"
                "<additive_expression>"
                "<multiplicative_binary_operation>"
                "<unary_expression>"
            )

    @tatsumasu()
    @nomemo
    def _additive_binary_operation_(self):  # noqa
        with self._choice():
            with self._option():
                self._additive_expression_()
                self.name_last_node("lhs")
                self._token("+")
                self.name_last_node("op")
                self._cut()
                self._multiplicative_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._additive_expression_()
                self.name_last_node("lhs")
                self._token("-")
                self.name_last_node("op")
                self._cut()
                self._multiplicative_expression_()
                self.name_last_node("rhs")
            self._error(
                "expecting one of: "
                "<additive_binary_operation>"
                "<multiplicative_expression>"
                "<additive_expression>"
                "<multiplicative_binary_operation>"
                "<unary_expression>"
            )
        self._define(["lhs", "op", "rhs"], [])

    @tatsumasu()
    @nomemo
    def _multiplicative_binary_operation_(self):  # noqa
        with self._choice():
            with self._option():
                self._multiplicative_expression_()
                self.name_last_node("lhs")
                self._token("/")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._multiplicative_expression_()
                self.name_last_node("lhs")
                self._token("*")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._multiplicative_expression_()
                self.name_last_node("lhs")
                self._token("%")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("rhs")
            with self._option():
                self._multiplicative_expression_()
                self.name_last_node("lhs")
                self._token("^")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("rhs")
            self._error(
                "expecting one of: "
                "<multiplicative_expression>"
                "<multiplicative_binary_operation>"
                "<unary_expression>"
            )
        self._define(["lhs", "op", "rhs"], [])

    @tatsumasu()
    @leftrec
    def _multiplicative_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._multiplicative_binary_operation_()
            with self._option():
                self._unary_expression_()
            self._error(
                "expecting one of: "
                "<multiplicative_expression>"
                "<multiplicative_binary_operation>"
                "<unary_expression> <unary_operation>"
                "<postfix_expression>"
            )

    @tatsumasu()
    @nomemo
    def _unary_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._unary_operation_()
            with self._option():
                self._postfix_expression_()
            self._error(
                "expecting one of: "
                "'+' '-' <unary_operation> <chain>"
                "<lookup> <index> <function_call>"
                "<primary_expression>"
                "<postfix_expression>"
            )

    @tatsumasu()
    def _unary_operation_(self):  # noqa
        with self._choice():
            with self._option():
                self._token("+")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("inner")
            with self._option():
                self._token("-")
                self.name_last_node("op")
                self._cut()
                self._unary_expression_()
                self.name_last_node("inner")
            self._error("expecting one of: " "'+' '-'")
        self._define(["inner", "op"], [])

    @tatsumasu()
    @leftrec
    def _postfix_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._chain_()
            with self._option():
                self._lookup_()
            with self._option():
                self._index_()
            with self._option():
                self._function_call_()
            with self._option():
                self._primary_expression_()
            self._error(
                "expecting one of: "
                "<chain_with_call> <chain_without_call>"
                "<chain> <lookup> <index> <function_call>"
                "<primary_expression>"
                "<postfix_expression> <variable>"
                "<literal_expression> '('"
            )

    @tatsumasu()
    def _primary_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._variable_()
            with self._option():
                self._literal_expression_()
            with self._option():
                self._token("(")
                self._expression_()
                self.name_last_node("@")
                self._token(")")
            self._error(
                "expecting one of: "
                "'this' <identifier> <variable> <bool>"
                "<number> <string> <array> 'namespace'"
                "<literal_expression> '('"
            )

    @tatsumasu()
    def _literal_expression_(self):  # noqa
        with self._choice():
            with self._option():
                self._bool_()
            with self._option():
                self._number_()
            with self._option():
                self._string_()
            with self._option():
                self._array_()
            with self._option():
                self._namespace_()
            self._error(
                "expecting one of: "
                "'true' 'false' <bool> <float> <integer>"
                "<number> '\"' <string> '[' <array>"
                "'namespace'"
            )

    @tatsumasu()
    @nomemo
    def _chain_(self):  # noqa
        with self._choice():
            with self._option():
                self._chain_with_call_()
            with self._option():
                self._chain_without_call_()
            self._error(
                "expecting one of: "
                "<chain> <lookup> <index> <function_call>"
                "<primary_expression>"
                "<postfix_expression> <chain_with_call>"
                "<chain_without_call>"
            )

    @tatsumasu()
    @nomemo
    def _chain_with_call_(self):  # noqa
        self._postfix_expression_()
        self.name_last_node("first")
        self._token(".")
        self._variable_()
        self.name_last_node("function")
        self._token("(")
        self._cut()

        def block2():
            self._expression_list_()
            self.name_last_node("arguments")

        self._closure(block2)
        self._token(")")
        self._define(["arguments", "first", "function"], [])

    @tatsumasu()
    @nomemo
    def _chain_without_call_(self):  # noqa
        self._postfix_expression_()
        self.name_last_node("first")
        self._token(".")
        self._cut()
        self._variable_()
        self.name_last_node("function")
        self._define(["first", "function"], [])

    @tatsumasu()
    @nomemo
    def _lookup_(self):  # noqa
        self._postfix_expression_()
        self.name_last_node("lhs")
        self._token("::")
        self._cut()
        self._variable_()
        self.name_last_node("rhs")
        self._define(["lhs", "rhs"], [])

    @tatsumasu()
    def _variable_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._token("this")
                with self._option():
                    self._identifier_()
                self._error("expecting one of: " "'this' (?!\\d)\\w+ <identifier>")
        self.name_last_node("name")
        self._define(["name"], [])

    @tatsumasu()
    @nomemo
    def _function_call_(self):  # noqa
        self._postfix_expression_()
        self.name_last_node("function")
        self._token("(")
        self._cut()
        self._expression_list_()
        self.name_last_node("arguments")
        self._token(")")
        self._define(["arguments", "function"], [])

    @tatsumasu()
    def _expression_list_(self):  # noqa
        def block0():
            self._expression_()
            self.add_last_node_to_name("@")

            def block2():
                self._token(",")
                self._expression_()
                self.add_last_node_to_name("@")

            self._closure(block2)

        self._closure(block0)

    @tatsumasu()
    def _if_then_else_(self):  # noqa
        self._token("if")
        self._cut()
        self._expression_()
        self.name_last_node("test")
        self._token("then")
        self._expression_()
        self.name_last_node("true")
        self._token("else")
        self._expression_()
        self.name_last_node("false")
        self._define(["false", "test", "true"], [])

    @tatsumasu()
    @nomemo
    def _index_(self):  # noqa
        self._postfix_expression_()
        self.name_last_node("lhs")
        self._token("[")
        self._expression_()
        self.name_last_node("rhs")
        self._token("]")
        self._define(["lhs", "rhs"], [])

    @tatsumasu()
    def _array_(self):  # noqa
        self._token("[")
        self._expression_list_()
        self.name_last_node("value")
        self._token("]")
        self._define(["value"], [])

    @tatsumasu()
    @isname
    def _identifier_(self):  # noqa
        self._pattern("(?!\\d)\\w+")

    @tatsumasu()
    def _bool_(self):  # noqa
        with self._choice():
            with self._option():
                self._token("true")
                self.name_last_node("value")
            with self._option():
                self._token("false")
                self.name_last_node("value")
            self._error("expecting one of: " "'true' 'false'")
        self._define(["value"], [])

    @tatsumasu()
    def _number_(self):  # noqa
        with self._choice():
            with self._option():
                self._float_()
            with self._option():
                self._integer_()
            self._error(
                "expecting one of: "
                "[0-9]+\\.[0-9]* \\.[0-9]+ <float> '0x'"
                "<hex> [0-9]+ <dec> <integer>"
            )

    @tatsumasu()
    def _dec_(self):  # noqa
        self._pattern("[0-9]+")
        self.name_last_node("value")
        self._define(["value"], [])

    @tatsumasu()
    def _hex_(self):  # noqa
        self._token("0x")
        self._pattern("[0-9a-fA-F]+")
        self.name_last_node("value")
        self._define(["value"], [])

    @tatsumasu()
    def _integer_(self):  # noqa
        with self._choice():
            with self._option():
                self._hex_()
            with self._option():
                self._dec_()
            self._error("expecting one of: " "'0x' <hex> [0-9]+ <dec>")

    @tatsumasu()
    def _float_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._pattern("[0-9]+\\.[0-9]*")
                with self._option():
                    self._pattern("\\.[0-9]+")
                self._error("expecting one of: " "[0-9]+\\.[0-9]* \\.[0-9]+")
        self.name_last_node("value")
        self._define(["value"], [])

    @tatsumasu()
    def _string_(self):  # noqa
        self._token('"')

        def block1():
            with self._choice():
                with self._option():
                    self._STRING_ESCAPE_SEQ_()
                with self._option():
                    self._pattern('[^"]+')
                self._error("expecting one of: " '<STRING_ESCAPE_SEQ> [^"]+')

        self._closure(block1)
        self.name_last_node("value")
        self._token('"')
        self._define(["value"], [])

    @tatsumasu()
    def _STRING_ESCAPE_SEQ_(self):  # noqa
        self._token("\\")
        self._pattern("\\w|\\S")


class SLANGSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def block(self, ast):  # noqa
        return ast

    def block_region(self, ast):  # noqa
        return ast

    def statement(self, ast):  # noqa
        return ast

    def forgot_semicolon(self, ast):  # noqa
        return ast

    def forgot_expression(self, ast):  # noqa
        return ast

    def bang(self, ast):  # noqa
        return ast

    def assignment(self, ast):  # noqa
        return ast

    def import_file(self, ast):  # noqa
        return ast

    def expression(self, ast):  # noqa
        return ast

    def function(self, ast):  # noqa
        return ast

    def parameter(self, ast):  # noqa
        return ast

    def namespace(self, ast):  # noqa
        return ast

    def definition(self, ast):  # noqa
        return ast

    def relational_expression(self, ast):  # noqa
        return ast

    def relational_binary_operation(self, ast):  # noqa
        return ast

    def additive_expression(self, ast):  # noqa
        return ast

    def additive_binary_operation(self, ast):  # noqa
        return ast

    def multiplicative_binary_operation(self, ast):  # noqa
        return ast

    def multiplicative_expression(self, ast):  # noqa
        return ast

    def unary_expression(self, ast):  # noqa
        return ast

    def unary_operation(self, ast):  # noqa
        return ast

    def postfix_expression(self, ast):  # noqa
        return ast

    def primary_expression(self, ast):  # noqa
        return ast

    def literal_expression(self, ast):  # noqa
        return ast

    def chain(self, ast):  # noqa
        return ast

    def chain_with_call(self, ast):  # noqa
        return ast

    def chain_without_call(self, ast):  # noqa
        return ast

    def lookup(self, ast):  # noqa
        return ast

    def variable(self, ast):  # noqa
        return ast

    def function_call(self, ast):  # noqa
        return ast

    def expression_list(self, ast):  # noqa
        return ast

    def if_then_else(self, ast):  # noqa
        return ast

    def index(self, ast):  # noqa
        return ast

    def array(self, ast):  # noqa
        return ast

    def identifier(self, ast):  # noqa
        return ast

    def bool(self, ast):  # noqa
        return ast

    def number(self, ast):  # noqa
        return ast

    def dec(self, ast):  # noqa
        return ast

    def hex(self, ast):  # noqa
        return ast

    def integer(self, ast):  # noqa
        return ast

    def float(self, ast):  # noqa
        return ast

    def string(self, ast):  # noqa
        return ast

    def STRING_ESCAPE_SEQ(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = "start"
    if not filename or filename == "-":
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = SLANGParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == "__main__":
    import json
    from tatsu.util import asjson

    ast = generic_main(main, SLANGParser, name="SLANG")
    data = asjson(ast)
    print(json.dumps(data, indent=2))
