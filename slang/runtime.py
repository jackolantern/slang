import os
import sys
import math
import logging
from typing import Union, Dict, List, Any

import tatsu
import tatsu.model

# from . import ext
from .syntax import types, terms, Position
from .syntax.terms import Environment

# generated by tatsu from slang.ebnf:
from .parser import SLANGParser

logging.basicConfig(level=logging.INFO)

parser_cache: Dict[str, terms.Expression] = {}

# WIP: Not used, part of the type system.
binary_operator_type_map = {
    ("+", types.Int, types.Int): types.Int,
    ("-", types.Int, types.Int): types.Int,
    ("*", types.Int, types.Int): types.Int,
    ("*", types.Int, types.Float): types.Float,
    ("*", types.Float, types.Float): types.Float,
    ("^", types.Int, types.Int): types.Int,
    ("^", types.Int, types.Float): types.Float,
    ("^", types.Float, types.Float): types.Float,
    ("%", types.Int, types.Int): types.Int,
    ("/", types.Int, types.Int): types.Float,
    ("/", types.Int, types.Float): types.Float,
    ("/", types.Float, types.Float): types.Float,
}

binary_operator_type_map.update(
    {(k[0], k[2], k[1]): v for k, v in binary_operator_type_map.items()}
)


def evaluate_unary_expression(op: str, value: terms.Value):
    if op == "+":
        return value
    elif op == "-":
        return -value
    # elif op == "~":
    #   return ~value
    elif op == "!":
        return not value
    raise RuntimeError(f"Unknown unary operator `{op}`.", None)


def evaluate_binary_expression(op: str, lhs: terms.Value, rhs: terms.Value):
    if op == "+":
        return lhs + rhs
    elif op == "-":
        return lhs - rhs
    elif op == "*":
        return lhs * rhs
    elif op == "/":
        return lhs / rhs
    elif op == "^":
        return lhs ** rhs
    elif op == "%":
        return lhs % rhs
    elif op == "==":
        return lhs == rhs
    elif op == "<":
        return lhs < rhs
    elif op == ">":
        return lhs > rhs
    elif op == "<=":
        return lhs <= rhs
    elif op == ">=":
        return lhs >= rhs
    raise RuntimeError(f"Unknown binary operator `{op}`.", None)


class ErrorId:
    MissingSemi = 1
    MissingExpr = 2


class BinaryOperationNotDefined(Exception):
    def __init__(self, op, lhs, rhs, ex=None):
        super.__init__(ex)
        self.op = op
        self.lhs = lhs
        self.rhs = rhs
        lhs = type(lhs).name
        rhs = type(rhs).name
        self.message = f"The operation '{op}' not defined between '{lhs}' and '{rhs}'."


class ParseError(Exception):
    def __init__(self, errors):
        self.errors = errors

    def print(self):
        for error in self.errors:
            error.print()


class RuntimeError(Exception):
    def __init__(self, message, position):
        self.error = ErrorMessage(0, message, position)

    def print(self):
        self.error.print()

    def value(self):
        return self

    def is_value(self) -> bool:
        return True


class ErrorMessage:
    def __init__(self, error_id, message, position_info):
        self.error_id = error_id
        self.message = message
        self.position_info = position_info

    def __str__(self):
        return f"Error: {self.error_id} at {self.position_info}.  {self.message}"

    def __repr__(self):
        return str(self)

    def print(self):
        if self.position_info:
            if self.position_info.start_line == self.position_info.end_line:
                message = f"({self.error_id}) Near line '{self.position_info.start_line}': {self.message}"
            else:
                message = f"({self.error_id}) Near lines '{self.position_info.start_line}-{self.position_info.end_line}': {self.message}"
        else:
            message = f"({self.error_id}) {self.message}"
        print(message, file=sys.stderr)


class Runner(tatsu.model.NodeWalker):
    def run(self, program, env: Environment):
        program = self.walk(program, env)
        while not program.is_value():
            program = self.walk(program, env)
        if isinstance(program, terms.Array):
            program = self.walk(program, env)
        return program

    def walk_IfThenElse(self, expr, env: Environment):
        test = self.run(expr.test, env)
        if test.value is True:
            return self.run(expr.true, env)
        elif test.value is False:
            return self.run(expr.false, env)
        raise Exception(f"Expected a bool, not a '{type(test)}'.")

    def walk_Block(self, block, env: Environment):
        new = env.push()
        for statement in block.statements:
            if isinstance(statement, terms.Import):
                ns = self.run(statement, new)
                assert isinstance(ns, terms.Namespace)
                for d in ns.definitions:
                    new.add_symbol(d.name, d.value)
            else:
                self.run(statement, new)
        return self.run(block.expression, new)

    def walk_Bang(self, bang, env: Environment):
        # typ = str(self.checker.judge(bang.expression, env))
        # expr = self.walk(bang.expression, env)
        print("!")  # expr, ":", typ, file=sys.stderr)

    def walk_Import(self, expr, env: Environment):
        return expr.program

    def walk_Assignment(self, stmt, env: Environment):
        value = self.run(stmt.expression, env)
        env.add_symbol(stmt.name, value)
        return value

    def walk_Function(self, function, env: Environment):
        return function

    def walk_FunctionDefinition(self, definition, env: Environment):
        return terms.Function(definition, env)

    def walk_Array(self, array, env: Environment):
        return terms.Array(
            [self.run(item, env) for item in array.value],
            position=array.position,
        )

    def walk_Namespace(self, ns, env: Environment):
        new = env.push()
        definitions = []
        for definition in ns.definitions:
            value = self.run(definition.value, new)
            new.add_symbol(definition.name, value)
            definitions.append(terms.NamespaceDefinition(definition.name, value))
        return terms.Namespace(definitions)

    def walk_NamespaceDefinition(self, definition, env: Environment):
        return definition

    def walk_Call(self, call, env: Environment):
        expression = self.run(call.expression, env)
        if not isinstance(expression, terms.Function):
            raise RuntimeError(
                f"Expected a function, not a '{type(expression)}'.", call.position
            )

        if len(call.arguments) != len(expression.definition.parameters):
            raise Exception(
                f"The function defined at {expression.definition.position} and called at {call.position} takes {len(expression.definition.parameters)} arguments, not {len(call.arguments)}."
            )
        arguments = [self.run(arg, env) for arg in call.arguments]
        if expression.definition.is_builtin:
            return self.run(expression.definition.body(self, env, arguments), env)

        pairs = zip([p.name for p in expression.definition.parameters], arguments)
        symbols = {name: value for name, value in pairs}
        symbols["this"] = expression
        return self.run(
            expression.definition.body, Environment(expression.environment, symbols)
        )

    def walk_BinaryOperation(self, expr, env: Environment):
        lhs = self.run(expr.lhs, env)
        rhs = self.run(expr.rhs, env)
        return evaluate_binary_expression(expr.op, lhs, rhs)

    def walk_UnaryOperation(self, expr, env: Environment):
        new = self.run(expr.expression, env)
        return evaluate_unary_expression(expr.op, new)

    def walk_Index(self, index, env: Environment):
        lhs = self.run(index.lhs, env)
        rhs = self.run(index.rhs, env)
        value = lhs.value[rhs.value]
        return self.run(value, env)

    def walk_Lookup(self, lookup, env: Environment):
        ns = self.run(lookup.expression, env)
        result = ns.lookup(lookup.var.name)
        return self.run(result, env)

    def walk_Variable(self, var, env: Environment):
        return self.run(env.find_symbol(var.name), env)

    def walk_Value(self, value, env: Environment):
        return value


class Semantics:
    def __init__(self, env):
        self.env = env
        self.errors = []
        self.universe = types.Universe()

    def block_region(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Block(ast.statements, ast.expression, position=position)

    def bang(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Bang(ast.expression, position=position)

    def function(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.FunctionDefinition(
            ast.parameters, ast.body, builtin=False, position=position
        )

    def parameter(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Parameter(ast.name, None, position=position)

    def namespace(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Namespace(ast.definitions, position=position)

    def import_file(self, ast):
        global parser_cache
        position = Position.from_parseinfo(ast.parseinfo)

        if ast.path.value in parser_cache:
            return terms.Import(
                ast.path, parser_cache[ast.path.value], position=position
            )
        program = parse_file(ast.path.value, self.env)
        parser_cache[ast.path.value] = program
        return terms.Import(ast.path, program, position=position)

    def assignment(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Assignment(ast.name, ast.expression, position=position)

    def definition(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.NamespaceDefinition(ast.name, ast.value, position=position)

    def function_call(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Call(ast.function, ast.arguments, position=position)

    def relational_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def additive_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def multiplicative_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def unary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.UnaryOperation(ast.op, ast.inner, position=position)

    def lookup(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Lookup(ast.lhs, ast.rhs, position=position)

    def chain_with_call(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Call(ast.function, [ast.first] + ast.arguments, position=position)

    def chain_without_call(self, ast):
        # return terms.Chain(ast.function, ast.first, position=position)
        position = Position.from_parseinfo(ast.parseinfo)
        arguments = [ast.first] + [
            terms.Variable(p.name) for p in ast.function.parameters
        ]
        return FunctionDefinition(
            ast.function.parameters[1:],
            terms.Call(ast.function, arguments),
            ast.function.is_builtin,
            position=position,
        )

    def if_then_else(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.IfThenElse(ast.test, ast.true, ast.false, position=position)

    def variable(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Variable(ast.name, position=position)

    def bool(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Value(ast.value == "true", position=position)

    def dec(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Value(int(ast.value), position=position)

    def hex(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Value(int(ast.value, 16), position=position)

    def float(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Value(float(ast.value), position=position)

    def string(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Value("".join(ast.value), position=position)

    def array(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        value = list(ast.value)
        return terms.Array(value, position=position)

    def index(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Index(ast.lhs, ast.rhs, position=position)

    def forgot_semicolon(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        self.errors.append(
            ErrorMessage(ErrorId.MissingSemi, "Missing semicolon.", position)
        )
        return None

    def forgot_expression(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        self.errors.append(
            ErrorMessage(ErrorId.MissingExpr, "Missing expression.", position)
        )
        return None


class TypeChecker:
    def __init__(self, universe):
        self.universe = universe

    def judge(self, term, env):
        if isinstance(term, terms.Function):
            return self._judge_function(term, env)
        if term.is_value():
            if isinstance(term, terms.Array):
                return self._judge_array_value(term, env)
            else:
                return self._judge_atomic_value(term)
        if isinstance(term, terms.IfThenElse):
            test = self.judge(term.test, env)
            if not self.universe.is_subtype(test, types.Bool):
                return None
            true = self.judge(term.true, env)
            false = self.judge(term.false, env)
            return self.universe.make_union(true, false)
        if isinstance(term, terms.BinaryOperation):
            return self._judge_binary_operation(term, env)
        return types.Any

    def _judge_function(self, term, env):
        body = self.judge(term.body, env)
        parameters = [p.typ if p.typ else types.Any for p in term.parameters]
        return types.Function(parameters, body)

    def _judge_binary_operation(self, term, env):
        lhs = self.judge(term.lhs, env)
        rhs = self.judge(term.rhs, env)
        return binary_operator_type_map.get((term.op, lhs, rhs))

    def _judge_array_value(self, term, env):
        general = types.Void
        for e in term.value:
            t = self.judge(e, env)
            if not t:
                return types.Any
            if self.universe.is_subtype(t, general):
                continue
            if self.universe.is_subtype(general, t):
                general = t
            general = self.universe.make_union(t, general)
        return types.Array(general)

    def _judge_atomic_value(self, term):
        if isinstance(term.value, bool):
            return types.Bool
        if isinstance(term.value, str):
            return types.String
        if isinstance(term.value, int):
            return types.Int
        if isinstance(term.value, float):
            return types.Float
        raise Exception(f"No atomic value for term '{term}'.")


def make_parser():
    parser = SLANGParser()
    # For development, you can uncomment this to use `caddy.ebnf` directly.
    # parser = None
    # with open("caddy.ebnf", "r") as fd:
    #     parser = tatsu.compile(fd.read())
    return parser


def run_file(path: str, env: Environment):
    path = os.path.join(os.getcwd(), path)
    program = parse_file(path, env)
    return run_program(program, env)


def run_string(string: str, env: Environment):
    program = parse_string(string, env)
    return run_program(program, env)


def run_program(program: terms.Expression, env: Environment) -> terms.Value:
    try:
        return Runner().run(program, env)
    except RuntimeError as e:
        e.print()
        raise


def parse_file(path, env: Environment):
    path = os.path.join(os.getcwd(), path)
    with open(path, "r") as fd:
        string = fd.read()
        return parse_string(string, env)


def parse_string(string: str, env: Environment) -> terms.Expression:
    """
    string: the program to parse
    kwargs:
        use_defaults=True: whether to include the extensions in `ext.py`
    """
    parser = make_parser()
    semantics = Semantics(env)
    try:
        result = parser.parse(
            string,
            semantics=semantics,
            comments_re=r"/\*.*?\*\/",
            eol_comments_re="//.*?$",
        )
        if len(semantics.errors):
            raise ParseError(semantics.errors)
        if not result:
            raise Exception("parse returned `None`!")
        return result
    except Exception:
        if len(semantics.errors):
            raise ParseError(semantics.errors)
        raise


def make_empty_env():
    return Environment(None)


def make_default_environment(update=None):
    def _echo(runner: Runner, env: Environment, arguments: List[terms.Expression]):
        assert len(arguments) == 1
        print(arguments[0].value)
        return arguments[0]

    def _length(runner: Runner, env: Environment, arguments: List[terms.Expression]):
        assert len(arguments) == 1
        array = runner.run(arguments[0], env)
        if not isinstance(array, terms.Array):
            raise RuntimeError(
                f"Expected array but found '{type(array)}': {array}.",
                array.position,
            )
        return terms.Value(len(array.value))

    def _make_math_unary(f):
        def _func(runner, env, arguments):
            assert len(arguments) == 1
            number = runner.run(arguments[0], env)
            assert isinstance(number, terms.Value) and isinstance(
                number.value, (int, float)
            ), "Expected number."
            return terms.Value(f(number.value))

        return terms.FunctionDefinition(
            [terms.Parameter("x", None)], _func, builtin=True
        )

    builtins = {
            "echo": terms.FunctionDefinition(
                [terms.Parameter("object", None)], _echo, builtin=True
            ),
            "length": terms.FunctionDefinition(
                [terms.Parameter("array", None)], _length, builtin=True
            ),
            "ceil": _make_math_unary(math.ceil),
            "floor": _make_math_unary(math.floor),
            "sin": _make_math_unary(math.sin),
            "cos": _make_math_unary(math.cos),
            "tan": _make_math_unary(math.tan),
            "sinh": _make_math_unary(math.sinh),
            "cosh": _make_math_unary(math.cosh),
            "tanh": _make_math_unary(math.tanh),
            "ln": _make_math_unary(math.log),
            "nslib": _make_nslib(),
        }
    if update:
        builtins.update(update)

    env = Environment(None)
    env.add_symbol("builtins", _make_namespace(builtins))
    return env


# Helper functions for creating builtins.
def _make_value(v):
    if isinstance(v, (str, int, float, bool)):
        return terms.Value(v)
    elif isinstance(v, (terms.Value, terms.Expression)):
        return v
    else:
        raise Exception(f"Can't convert '{v}' into value.")


def _make_namespace(d: Dict[str, Any]) -> terms.Namespace:
    return terms.Namespace(
        [terms.NamespaceDefinition(k, _make_value(v)) for (k, v) in d.items()]
    )


def _make_nslib():
    # ns, name
    def _has(
        runner: Runner, env: Environment, arguments: List[terms.Expression]
    ) -> terms.Expression:
        assert len(arguments) == 2
        ns = runner.run(arguments[0], env)
        name = runner.run(arguments[1], env)
        assert type(ns) == terms.Namespace
        assert type(name) == terms.Value and type(name.value) == str
        return terms.Value(ns.has(name.value))

    # ns, name
    def _remove(
        runner: Runner, env: Environment, arguments: List[terms.Expression]
    ) -> terms.Expression:
        assert len(arguments) == 2
        ns = runner.run(arguments[0], env)
        name = runner.run(arguments[1], env)
        assert type(ns) == terms.Namespace
        assert type(name) == terms.Value and type(name.value) == str
        return ns.remove(name.value)

    # ns, ns
    def _combine(
        runner: Runner, env: Environment, arguments: List[terms.Expression]
    ) -> terms.Expression:
        assert len(arguments) == 2
        lhs = runner.run(arguments[0], env)
        rhs = runner.run(arguments[1], env)
        assert type(lhs) == terms.Namespace
        assert type(rhs) == terms.Namespace
        return lhs.combine(rhs)

    return terms.Namespace(
        [
            terms.NamespaceDefinition(
                "has",
                terms.FunctionDefinition(
                    [terms.Parameter("ns", None), terms.Parameter("name", None)],
                    _has,
                    builtin=True,
                ),
            ),
            terms.NamespaceDefinition(
                "remove",
                terms.FunctionDefinition(
                    [terms.Parameter("ns", None), terms.Parameter("name", None)],
                    _remove,
                    builtin=True,
                ),
            ),
            terms.NamespaceDefinition(
                "combine",
                terms.FunctionDefinition(
                    [terms.Parameter("lhs", None), terms.Parameter("rhs", None)],
                    _combine,
                    builtin=True,
                ),
            ),
        ]
    )
