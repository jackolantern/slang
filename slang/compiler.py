import os
import sys
import math
from typing import Dict, List, Any

import tatsu
import tatsu.model

# from . import ext
from .syntax import types, terms, values, Position

# generated by tatsu from slang.ebnf:
from .parser import SLANGParser
from .pretty import pprint, pretty

parser_cache: Dict[str, terms.Expression] = {}

# WIP: Not used, part of the type system.
binary_operator_type_map = {
    ("+", types.Int, types.Int): types.Int,
    ("-", types.Int, types.Int): types.Int,
    ("*", types.Int, types.Int): types.Int,
    ("*", types.Int, types.Float): types.Float,
    ("*", types.Float, types.Float): types.Float,
    ("^", types.Int, types.Int): types.Int,
    ("^", types.Int, types.Float): types.Float,
    ("^", types.Float, types.Float): types.Float,
    ("%", types.Int, types.Int): types.Int,
    ("/", types.Int, types.Int): types.Float,
    ("/", types.Int, types.Float): types.Float,
    ("/", types.Float, types.Float): types.Float,
}

binary_operator_type_map.update(
    {(k[0], k[2], k[1]): v for k, v in binary_operator_type_map.items()}
)


class ErrorId:
    MissingSemi = 1
    MissingExpr = 2


class RuntimeError(Exception):
    def __init__(self, message, ex=None):
        super.__init__()
        self.ex = ex
        self.message = message if message else str(ex)

    def __str__(self):
        return self.message


class EnvironmentError(Exception):
    pass


class BinaryOperationNotDefined(Exception):
    def __init__(self, op, lhs, rhs, ex=None):
        super.__init__(ex)
        self.op = op
        self.lhs = lhs
        self.rhs = rhs
        lhs = type(lhs).name
        rhs = type(rhs).name
        self.message = f"The operation '{op}' not defined between '{lhs}' and '{rhs}'."


class ParseError(Exception):
    def __init__(self, errors):
        self.errors = errors

    def print(self):
        for error in self.errors:
            if error.position_info:
                if error.position_info.start_line == error.position_info.end_line:
                    print(
                        f"({error.error_id}) Near line '{error.position_info.start_line}': {error.message}",
                        file=sys.stderr,
                    )
                else:
                    print(
                        f"({error.error_id}) Near lines '{error.position_info.start_line}-{error.position_info.end_line}': {error.message}",
                        file=sys.stderr,
                    )
            else:
                print(f"({error.error_id}) {error.message}", file=sys.stderr)


class ErrorMessage:
    def __init__(self, error_id, message, position_info):
        self.error_id = error_id
        self.message = message
        self.position_info = position_info

    def __str__(self):
        return f"Error: {self.error_id} at {self.position_info}.  {self.message}"

    def __repr__(self):
        return str(self)


class Scope:
    def __init__(self, parent, symbols=None):
        self.parent = parent
        self.symbols = symbols if symbols else {}

    def push(self):
        return Scope(self)

    def keys(self):
        if self.parent is None:
            return list(self.symbols.keys())
        else:
            return list(self.symbols.keys()) + self.parent.keys()

    def add_symbol(self, name, value):
        existing = self.symbols.get(name)
        if existing:
            raise EnvironmentError(
                f"This scope already defines a value named '{name}'."
            )
        else:
            self.symbols[name] = value

    def find_symbol(self, name):
        symbol = self.symbols.get(name, None)
        if symbol:
            if isinstance(symbol, (terms.Bound, terms.Variable)):
                return symbol
            return terms.Reference(name, symbol)
        if self.parent:
            return self.parent.find_symbol(name)
        else:
            # return terms.Variable(name)
            raise EnvironmentError(f"No symbol named '{name}'.")

    def get_root(self):
        if self.parent:
            return self.parent.get_root()
        return self


class BaseTransformer(tatsu.model.NodeWalker):
    def walk_Block(self, block, *args, **kwargs):
        statements = [self.walk(s, *args, **kwargs) for s in block.statements]
        expression = self.walk(block.expression, *args, **kwargs)
        return terms.Block(statements, expression)

    def walk_Bang(self, bang, *args, **kwargs):
        return terms.Bang(self.walk(bang.expression, *args, **kwargs))

    def walk_Assignment(self, assign, *args, **kwargs):
        return terms.Assignment(
            assign.name, self.walk(assign.expression, *args, **kwargs)
        )

    def walk_Import(self, imp, *args, **kwargs):
        return imp

    def walk_Namespace(self, ns, *args, **kwargs):
        return terms.Namespace([self.walk(d, *args, **kwargs) for d in ns.definitions])

    def walk_NamespaceDefinition(self, definition, *args, **kwargs):
        return terms.NamespaceDefinition(
            definition.name, self.walk(definition.value, *args, **kwargs)
        )

    def walk_FunctionDef(self, function, *args, **kwargs):
        if function.is_builtin():
            return self
        body = self.walk(function.body, *args, **kwargs)
        return terms.FunctionDef(function.parameters, body, position=function.position)

    def walk_FunctionRef(self, function, *args, **kwargs):
        if function.is_builtin():
            body = function.body
        else:
            body = self.walk(function.body, *args, **kwargs)
        return terms.FunctionRef(function.parameters, body, position=function.position)

    def walk_Call(self, call, *args, **kwargs):
        expression = self.walk(call.expression, *args, **kwargs)
        arguments = [self.walk(arg, *args, **kwargs) for arg in call.arguments]
        return terms.Call(expression, arguments, position=call.position)

    def walk_Chain(self, chain, *args, **kwargs):
        function = self.walk(chain.function, *args, **kwargs)
        argument = self.walk(chain.argument, *args, **kwargs)
        return terms.Chain(function, argument)

    def walk_IfThenElse(self, expr, *args, **kwargs):
        test = self.walk(expr.test, *args, **kwargs)
        true = self.walk(expr.true, *args, **kwargs)
        false = self.walk(expr.false, *args, **kwargs)
        return terms.IfThenElse(test, true, false)

    def walk_UnaryOperation(self, unaryop, *args, **kwargs):
        return terms.UnaryOperation(
            unaryop.op, self.walk(unaryop.expression, *args, **kwargs)
        )

    def walk_BinaryOperation(self, binop, *args, **kwargs):
        lhs = self.walk(binop.lhs, *args, **kwargs)
        rhs = self.walk(binop.rhs, *args, **kwargs)
        return terms.BinaryOperation(binop.op, lhs, rhs)

    def walk_Lookup(self, lookup, *args, **kwargs):
        expression = self.walk(lookup.expression, *args, **kwargs)
        return terms.Lookup(expression, lookup.var)

    def walk_Index(self, index, *args, **kwargs):
        lhs = self.walk(index.lhs, *args, **kwargs)
        rhs = self.walk(index.rhs, *args, **kwargs)
        return terms.Index(lhs, rhs)

    def walk_Reference(self, ref, *args, **kwargs):
        return terms.Reference(ref.name, self.walk(ref.value, *args, **kwargs))

    def walk_Array(self, array, *args, **kwargs):
        return values.Array([self.walk(e, *args, **kwargs) for e in array.value])

    def walk_Value(self, value, *args, **kwargs):
        return value

    def walk_Bound(self, bound, *args, **kwargs):
        return bound

    def walk_Variable(self, var, *args, **kwargs):
        return var

    def walk_This(self, this, *args, **kwargs):
        return this


class BindingTransform(BaseTransformer):
    def walk_Variable(self, var, parameters, offset, ref):
        if var.name == "this":
            return terms.This(ref, position=var.position)
        if var.name in parameters:
            index = parameters.index(var.name)
            return terms.Bound(var.name, index + offset)
        return var

    def walk_FunctionDef(self, function, parameters, offset, ref):
        names = [p.name for p in function.parameters]
        parameters = [p for p in parameters if p not in names]
        body = self.walk(
            function.body, parameters, len(function.parameters) + offset, self
        )
        return terms.FunctionDef(function.parameters, body, position=function.position)


class RecursionTransform(BaseTransformer):
    def walk_This(self, this, func, ref):
        if this.value == func:
            this.value = ref
        return this


class Compiler(BaseTransformer):
    def __init__(self, universe):
        super().__init__()
        self.checker = TypeChecker(universe)

    def walk_Block(self, block, scope):
        new = scope.push()
        for statement in block.statements:
            if isinstance(statement, terms.Import):
                ns = self.walk(statement, new)
                assert isinstance(ns, terms.Namespace)
                for d in ns.definitions:
                    new.add_symbol(d.name, d.value)
            else:
                self.walk(statement, new)
        return self.walk(block.expression, new)

    def walk_Bang(self, bang, scope):
        typ = str(self.checker.judge(bang.expression, scope))
        expr = self.walk(bang.expression, scope)
        expr = pretty(expr)
        print(expr, ":", typ, file=sys.stderr)

    def walk_Import(self, expr, scope):
        return expr.program

    def walk_Assignment(self, stmt, scope):
        value = self.walk(stmt.expression, scope)
        scope.add_symbol(stmt.name, value)

    def walk_Namespace(self, ns, scope):
        new = scope.push()
        definitions = []
        for definition in ns.definitions:
            value = self.walk(definition.value, new)
            new.add_symbol(definition.name, value)
            definitions.append(terms.NamespaceDefinition(definition.name, value))
        return terms.Namespace(definitions)

    def walk_FunctionDef(self, function, scope):
        if isinstance(function, terms.FunctionRef):
            return function
        if function.is_builtin():
            new_function = terms.FunctionRef(function.parameters, function.body)
        else:
            body = BindingTransform().walk(
                function.body, [p.name for p in function.parameters], 0, function
            )
            body = self.walk(body, scope)
            # By this point, all of the children `FunctionDef`s have been converted into `FunctionRef`s.
            new_function = terms.FunctionRef(function.parameters, body)
            # TODO: this mutates the ref in place, and is a little hacky...
            new_function.body = RecursionTransform().walk(
                new_function.body, function, new_function
            )
        return new_function

    def walk_FunctionRef(self, function, scope):
        return function

    def walk_Chain(self, chain, scope):
        function = self.walk(chain.function, scope)
        while isinstance(function, terms.Reference):
            function = function.value
        assert isinstance(function, terms.FunctionDef)
        argument = self.walk(chain.argument, scope)
        parameters = function.parameters[1:]
        arguments = [argument] + [terms.Variable(p.name) for p in parameters]
        position = Position.from_parseinfo(chain.parseinfo)
        return self.walk(
            terms.FunctionDef(
                parameters, terms.Call(function, arguments, position=position)
            ),
            scope,
            position=position,
        )

    def walk_Call(self, call, scope):
        expression = self.walk(call.expression, scope)
        arguments = [self.walk(arg, scope) for arg in call.arguments]
        return terms.Call(expression, arguments, position=call.position)

    def walk_IfThenElse(self, expr, scope):
        test = self.walk(expr.test, scope)
        if isinstance(test, values.Value):
            if test.value is True:
                return self.walk(expr.true, scope)
            else:
                assert test.value is False
                return self.walk(expr.false, scope)
        true = self.walk(expr.true, scope)
        false = self.walk(expr.false, scope)
        return terms.IfThenElse(test, true, false)

    def walk_UnaryOperation(self, expr, scope):
        return super().walk_UnaryOperation(expr, scope).simplify()

    def walk_BinaryOperation(self, expr, scope):
        return super().walk_BinaryOperation(expr, scope).simplify()

    def walk_Reference(self, ref, scope):
        return ref

    def walk_Variable(self, var, scope):
        return self.walk(scope.find_symbol(var.name), scope)

    def walk_Lookup(self, lookup, scope):
        expression = self.walk(lookup.expression, scope)
        if isinstance(expression, terms.Namespace):
            ndef = expression.lookup(lookup.var.name)
            return self.walk(ndef.value, scope)
        return terms.Lookup(expression, lookup.var)

    def walk_Index(self, index, scope):
        return terms.Index(self.walk(index.lhs, scope), self.walk(index.rhs, scope))


# TODO: Would memoizing function calls be worthwhile?  MRU cache?
class Runner(BaseTransformer):
    def run(self, program):
        while not program.is_value():
            program = self.walk(program)
        if isinstance(program, values.Array):
            return values.Array(
                [self.run(item) for item in program.value], position=program.position
            )
        elif isinstance(program, terms.Namespace):
            definitions = []
            for definition in program.definitions:
                value = self.run(definition.value)
                definitions.append(terms.NamespaceDefinition(definition.name, value))
            return terms.Namespace(definitions)
        return program

    def walk_IfThenElse(self, expr):
        test = self.walk(expr.test)
        if test.value is True:
            return self.walk(expr.true)
        elif test.value is False:
            return self.walk(expr.false)
        raise Exception(f"Expected a bool, not a '{type(test)}'.")

    def walk_Namespace(self, ns):
        return ns

    def walk_FunctionRef(self, function):
        return function

    def walk_Call(self, call):
        expression = self.walk(call.expression)
        while not isinstance(expression, terms.FunctionRef):
            previous = expression
            expression = self.walk(expression)
            if expression == previous:
                raise Exception(
                    f"({call.position}) : Expected a function, not a '{type(expression)}'."
                )
        result = expression.call(self, call.arguments)
        return self.walk(result)

    def walk_BinaryOperation(self, expr):
        lhs = self.walk(expr.lhs)
        rhs = self.walk(expr.rhs)
        return terms.BinaryOperation(expr.op, lhs, rhs).simplify()

    def walk_UnaryOperation(self, expr):
        new = self.walk(expr.expression)
        return terms.UnaryOperation(expr.op, new).simplify()

    def walk_This(self, this):
        return this.value

    def walk_Reference(self, ref):
        # TODO: Add a check for cycles.
        value = ref.value
        while isinstance(value, terms.Reference):
            value = value.value
        return self.walk(value)

    def walk_Index(self, index):
        lhs = self.walk(index.lhs)
        rhs = self.walk(index.rhs)
        value = lhs.value[rhs.value]
        if isinstance(value, values.Value):
            return value
        return values.Value(self.walk(value))

    def walk_Lookup(self, lookup):
        ns = self.walk(lookup.expression)
        result = ns.lookup(lookup.var.name)
        definition = self.walk(result)
        return definition.value

    def walk_Variable(self, var):
        raise Exception(f"Encountered free variable '{var.name}'.")


class Semantics:
    def __init__(self, scope):
        self.scope = scope
        self.errors = []
        self.universe = types.Universe()

    def block_region(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Block(ast.statements, ast.expression, position=position)

    def bang(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Bang(ast.expression, position=position)

    def function(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.FunctionDef(ast.parameters, ast.body, position=position)

    def parameter(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Parameter(ast.name, None, position=position)

    def namespace(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Namespace(ast.definitions, position=position)

    def import_file(self, ast):
        global parser_cache
        position = Position.from_parseinfo(ast.parseinfo)

        if ast.path.value in parser_cache:
            return terms.Import(
                ast.path, parser_cache[ast.path.value], position=position
            )
        program = parse_file(ast.path.value, self.scope)
        program = compile_program(program, self.scope)
        parser_cache[ast.path.value] = program
        return terms.Import(ast.path, program, position=position)

    def assignment(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Assignment(ast.name, ast.expression, position=position)

    def definition(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.NamespaceDefinition(ast.name, ast.value, position=position)

    def function_call(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Call(ast.function, ast.arguments, position=position)

    def relational_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def additive_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def multiplicative_binary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.BinaryOperation(ast.op, ast.lhs, ast.rhs, position=position)

    def unary_operation(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.UnaryOperation(ast.op, ast.inner, position=position)

    def lookup(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Lookup(ast.lhs, ast.rhs, position=position)

    def chain_with_call(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Call(ast.function, [ast.first] + ast.arguments, position=position)

    def chain_without_call(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Chain(ast.function, ast.first, position=position)

    def if_then_else(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.IfThenElse(ast.test, ast.true, ast.false, position=position)

    def variable(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Variable(ast.name, position=position)

    def bool(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return values.Value(ast.value == "true", position=position)

    def dec(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return values.Value(int(ast.value), position=position)

    def hex(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return values.Value(int(ast.value, 16), position=position)

    def float(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return values.Value(float(ast.value), position=position)

    def string(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return values.Value("".join(ast.value), position=position)

    def array(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        value = list(ast.value)
        return values.Array(value, position=position)

    def index(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        return terms.Index(ast.lhs, ast.rhs, position=position)

    def forgot_semicolon(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        self.errors.append(
            ErrorMessage(ErrorId.MissingSemi, "Missing semicolon.", position)
        )
        return None

    def forgot_expression(self, ast):
        position = Position.from_parseinfo(ast.parseinfo)
        self.errors.append(
            ErrorMessage(ErrorId.MissingExpr, "Missing expression.", position)
        )
        return None


class TypeChecker:
    def __init__(self, universe):
        self.universe = universe

    def judge(self, term, scope):
        if isinstance(term, terms.Reference):
            return self.judge(term.value, scope)
        if isinstance(term, terms.FunctionDef):
            return self._judge_function(term, scope)
        if term.is_value():
            if isinstance(term, values.Array):
                return self._judge_array_value(term, scope)
            else:
                return self._judge_atomic_value(term)
        if isinstance(term, terms.IfThenElse):
            test = self.judge(term.test, scope)
            if not self.universe.is_subtype(test, terms.BoolType):
                return None
            true = self.judge(term.true, scope)
            false = self.judge(term.false, scope)
            return self.universe.make_union(true, false)
        if isinstance(term, terms.BinaryOperation):
            return self._judge_binary_operation(term, scope)
        return types.Any

    def _judge_function(self, term, scope):
        body = self.judge(term.body, scope)
        parameters = [p.typ if p.typ else types.Any for p in term.parameters]
        return types.Function(parameters, body)

    def _judge_binary_operation(self, term, scope):
        lhs = self.judge(term.lhs, scope)
        rhs = self.judge(term.rhs, scope)
        return binary_operator_type_map.get((term.op, lhs, rhs))

    def _judge_array_value(self, term, scope):
        general = terms.VoidType
        for e in term.value:
            t = self.judge(e, scope)
            if not t:
                return types.Any
            if self.universe.is_subtype(t, general):
                continue
            if self.universe.is_subtype(general, t):
                general = t
            general = self.universe.make_union(t, general)
        return types.ArrayType(general)

    def _judge_atomic_value(self, term):
        if isinstance(term.value, bool):
            return types.Bool
        if isinstance(term.value, str):
            return types.String
        if isinstance(term.value, int):
            return types.Int
        if isinstance(term.value, float):
            return types.Float
        raise Exception(f"No atomic value for term '{term}'.")


def make_parser():
    parser = SLANGParser()
    # For development, you can uncomment this to use `caddy.ebnf` directly.
    # parser = None
    # with open("caddy.ebnf", "r") as fd:
    #     parser = tatsu.compile(fd.read())
    return parser


def run_file(path, scope: Scope, **kwargs):
    path = os.path.join(os.getcwd(), path)
    program = parse_file(path, scope)
    program = compile_program(program, scope)
    return run_compiled_program(program)


def run_string(string: str, scope: Scope):
    program = parse_string(string, scope)
    program = compile_program(program, scope)
    return run_compiled_program(program)


def parse_file(path, scope: Scope):
    path = os.path.join(os.getcwd(), path)
    with open(path, "r") as fd:
        string = fd.read()
        return parse_string(string, scope)


def parse_string(string: str, scope: Scope):
    """
    string: the program to parse
    kwargs:
        use_defaults=True: whether to include the extensions in `ext.py`
    """
    parser = make_parser()
    semantics = Semantics(scope)
    try:
        result = parser.parse(
            string,
            semantics=semantics,
            comments_re=r"/\*.*?\*\/",
            eol_comments_re="//.*?$",
        )
        if len(semantics.errors):
            raise ParseError(semantics.errors)
        return result
    except Exception:
        if len(semantics.errors):
            raise ParseError(semantics.errors)
        raise


def compile_program(program, scope):
    compiler = Compiler(types.Universe())
    return compiler.walk(program, scope)


def run_compiled_program(program) -> values.Value:
    return Runner().run(program)


def make_empty_scope():
    return Scope(None)


def make_default_scope():
    def _echo(runner, arguments):
        assert len(arguments) == 1
        print(pretty(arguments[0]))
        return arguments[0]

    def _length(runner, arguments):
        assert len(arguments) == 1
        array = runner.walk(arguments[0])
        assert isinstance(
            array, values.Array
        ), f"Expected array but found '{type(arguments[0])}'"
        return values.Value(len(array.value))

    def _make_math_unary(f):
        def _func(runner, arguments):
            assert len(arguments) == 1
            number = runner.run(arguments[0])
            assert isinstance(number, values.Value) and isinstance(
                number.value, (int, float)
            ), "Expected number."
            return values.Value(f(number.value))
        return terms.FunctionRef([terms.Parameter("x", None)], _func)

    builtins = _make_namespace({
        "echo": terms.FunctionRef([terms.Parameter("object", None)], _echo),
        "length": terms.FunctionRef([terms.Parameter("array", None)], _length),
        "ceil": _make_math_unary(math.ceil),
        "floor": _make_math_unary(math.floor),
        "sin": _make_math_unary(math.sin),
        "cos": _make_math_unary(math.cos),
        "tan": _make_math_unary(math.tan),
        "sinh": _make_math_unary(math.sinh),
        "cosh": _make_math_unary(math.cosh),
        "tanh": _make_math_unary(math.tanh),
        "ln": _make_math_unary(math.log),
        "nslib": _make_nslib(),
    })

    scope = Scope(None)
    scope.add_symbol("builtins", builtins)
    return scope


# Helper functions for creating builtins.
def _make_value(v):
    if isinstance(v, (str, int, float, bool)):
        return values.Value(v)
    elif isinstance(v, (values.Value, terms.Expression)):
        return v
    else:
        raise Exception(f"Can't convert '{v}' into value.")


def _make_namespace(d: Dict[str, Any]) -> terms.Namespace:
    return terms.Namespace([terms.NamespaceDefinition(k, _make_value(v)) for (k, v) in d.items()])


def _make_nslib():
    # ns, name
    def _has(runner, arguments):
        assert len(arguments) == 2
        ns = runner.walk(arguments[0])
        name = runner.run(arguments[1])
        assert type(ns) == terms.Namespace
        assert type(name) == values.Value and type(name.value) == str
        return values.Value(ns.has(name.value))

    # ns, name
    def _remove(runner, arguments):
        assert len(arguments) == 2
        ns = runner.walk(arguments[0])
        name = runner.run(arguments[1])
        assert type(ns) == terms.Namespace
        assert type(name) == values.Value and type(name.value) == str
        return ns.remove(name.value)

    # ns, ns
    def _combine(runner, arguments):
        assert len(arguments) == 2
        lhs = runner.walk(arguments[0])
        rhs = runner.walk(arguments[1])
        assert type(lhs) == terms.Namespace
        assert type(rhs) == terms.Namespace
        return lhs.combine(rhs)

    return terms.Namespace(
        [
            terms.NamespaceDefinition(
                "has",
                terms.FunctionRef(
                    [terms.Parameter("ns", None), terms.Parameter("name", None)], _has
                ),
            ),
            terms.NamespaceDefinition(
                "remove",
                terms.FunctionRef(
                    [terms.Parameter("ns", None), terms.Parameter("name", None)],
                    _remove,
                ),
            ),
            terms.NamespaceDefinition(
                "combine",
                terms.FunctionRef(
                    [terms.Parameter("lhs", None), terms.Parameter("rhs", None)],
                    _combine,
                ),
            ),
        ]
    )
